Ein verteiltes System ist nach der Definition von Andrew S. Tanenbaum ein Zusammenschluss unabhängiger Computer, die sich für den Benutzer als ein einziges System präsentieren. Peter Löhr definiert es etwas grundlegender als „eine Menge interagierender Prozesse (oder Prozessoren), die über keinen gemeinsamen Speicher verfügen und daher über Nachrichten miteinander kommunizieren“. Das Teilgebiet in der Informatik, welches sich mit verteilten Systemen und deren Algorithmen beschäftigt, wird Verteiltes Rechnen oder Verteilte Verarbeitung (englisch: Distributed Computing) genannt.[1] Meist unterscheidet man in Mit verteilten Systemen kann eine echte Nebenläufigkeit realisiert werden; das heißt, dass mehrere Prozesse echt gleichzeitig ausgeführt werden können. Darüber hinaus ist ein verteiltes System in der Regel auch besser skalierbar als ein einzelner Computer, da man auf einfache Art und Weise durch Hinzufügen weiterer Rechner die Leistungsfähigkeit erhöhen kann. Ein häufig anzutreffendes Szenario ist auch die Bereitstellung von entfernten Ressourcen, wie es bei der Wikipedia der Fall ist. Außerdem werden verteilte Systeme zur Erhöhung der Ausfallsicherheit benutzt, indem bestimmte Funktionalitäten von mehreren Rechnern angeboten werden (Redundanz), so dass beim Ausfall eines Rechners die gleiche Funktionalität von einem weiteren Rechner angeboten wird. In vielen Fällen gibt es auch wirtschaftliche Gründe, um preisgünstige Rechner zu vernetzen, statt einen teuren Supercomputer anzuschaffen. Dies machen sich beispielsweise Volunteer-Computing-Projekte wie SETI@home zunutze, die brachliegende Rechenleistung von Einzelplatzrechnern zur Lösung komplexer Probleme nutzen. Nachdem im März 2020 eines der ersten und größten öffentlichen Volunteer-Verteiltes System Projekte SETI@home sein Ende am 31. März 2020 bekannt gab[2][3][4] und aufgrund einer erhöhten Interesse durch die COVID-19-Pandemie, wird das Verteilte System Folding@home das erste Computing-System das ein exaFLOPS erreicht.[5][6][7] Das System simulierte Proteinfaltung für Forschungen zu COVID-19 und erreichte am 13. April eine Geschwindigkeit von ca. 2.43 x86 exaFLOPS – einige Male schneller als der vorherige Rekordhalter, Supercomputer Summit.[8] Weitere Gründe:[9] Für den Benutzer sowie für die Applikation eines verteilten Systems ist die Art der Verteilung nicht relevant und idealerweise auch nicht ersichtlich. Das System verhält sich transparent (i. S. v. durchsichtig), als hätte der Nutzer es mit einem Gesamtsystem zu tun. Da es bei verteilten Systemen zu einem Teilausfall kommen kann, von dem einzelne Rechner oder Teile des Netzwerkes betroffen sind, sollte darauf geachtet werden, dass es keinen Single Point of Failure im System gibt. Dabei ist zu bemerken, dass die Wahrscheinlichkeit eines Fehlverhaltens eines Prozesses mit der Anzahl der beteiligten Prozesse steigt (siehe Verfügbarkeit). Ein wichtiges Teilproblem davon ist, einen Teilausfall erst zu bemerken. Es existieren keine voll zufriedenstellenden Methoden, die einen Teilausfall erkennen und beheben können. Eine Möglichkeit wäre der Heartbeat oder ein regelmäßiges Anpingen der beteiligten Systeme. Diese Möglichkeiten sind jedoch nicht perfekt. In verteilten Systemen ist zwar eine echte Nebenläufigkeit möglich, allerdings können Prozesse in unterschiedlichen Geschwindigkeiten abgearbeitet werden. Eine hierdurch bedingte starke Form von Nicht-Determinismus erhöht die Anforderungen zur Synchronisierung von Prozessen. Aus diesem Grunde ist eine Nebenläufigkeitskontrolle meist sehr wichtig: Zum einen im Bezug auf Transaktionen und zum anderen beim Zugriff auf gemeinsame Ressourcen (Mutex). Außerdem kann es in verteilten Systemen immer Deadlocks geben. Gesamtzustände (Summe der Zustände aller beteiligten Prozesse) und Abläufe können in einem verteilten System oft im Nachhinein nicht nachvollzogen werden. Eine Diagnose im Fehlerfall wird hierdurch erschwert. Verteilte Systeme teilen sich keinen gemeinsamen Speicher und müssen ihre gesamte Kommunikation darum durch das Versenden und Empfangen von Nachrichten realisieren. Eine solche Kommunikation ist sehr fehleranfällig, so dass es zu Problemen durch Verfälschung von Nachrichten, Duplizierung von Nachrichten und den Verlust von Nachrichten kommen kann. Außerdem ist die Nachrichtenlaufzeit unvorhersehbar, so dass man nie mit Sicherheit vorhersehen kann, ob ein System ausgefallen ist oder ob es nur eine lange Antwortzeit hat. Ein weiteres Problem der Nachrichten ist, dass diese Art der Kommunikation unsicher sein kann, also durch Angreifer abgehört oder bewusst manipuliert werden kann, und über eine Infrastruktur laufen muss, die (wie das Internet) vielleicht nicht vollständig für Gruppen-basierte Kommunikation geeignet ist. Bei komplexen Prozessen ist es oft notwendig, einen gemeinsamen Zeitbegriff in der Datenverarbeitung zu realisieren (Synchronisierung ohne Prozess-Kommunikation). Hierfür muss sichergestellt werden, dass die jedem Prozess bekannte Zeit nur mit kleinen Abweichungen übereinstimmt. So lassen sich verteilte Transaktionen sicher durchführen, da hier mit Hilfe von Timeouts eine Veralterung ausgesendeter Nachrichten vermieden wird. (Siehe auch „Algorithmen zur Uhren-Synchronisation“ unten). Außerdem erschweren verteilte Systeme die (zentrale) Administration, besonders bei nicht-strukturierten Topologien. Je nach Anwendung treffen Millionen unterschiedlich konfigurierter Rechner aufeinander, die außerdem noch völlig fremden Personen gehören können.[10][11] Bei verteilten Systemen geht man von unterschiedlichen Kommunikationsmodellen aus. Das Ziel eines Broadcasts ist die Verteilung einer Information im gesamten Netz. Beispiele: Auswahlalgorithmen können in zwei Kategorien unterteilt werden: Algorithmen, die aus einer Menge von identischen Knoten einen eindeutigen Knoten auswählen und Maximumsalgorithmen, die aus einer Menge von Knoten mit eindeutiger ID den Knoten mit der größten ID auswählen.